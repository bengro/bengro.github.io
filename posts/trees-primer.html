<!DOCTYPE html><html><head><link rel="stylesheet" href="/main.css"></head><body><h2>Abstract</h2><p>Tree-based data structures are excellent building blocks for algorithms and abstract data structures. Trees you can find the the forest as well as in Priority Queues, Sets or Hash Maps. This post walks through basic tree-based data structures, their properties as well as aspects of their implementation. It&#39;s a compilation of notes I gathered when working through Binary Tree interview problems. </p>
<h2>Terminology</h2><p>Let&#39;s get an overview of tree-based abstract data structures we are going to look at:</p>
<ul>
<li>A <strong>Tree</strong> <em>T</em> is a acyclic graph consisting of vertices and edges. It has precisely V-1 edges, where V denotes the number f vertices in <em>T</em>. It can be interpreted as directed graph or an undirected graph.</li>
<li>A <strong>Binary Tree</strong> is a tree, with the additional constraint that each vertex u can have at most two children. The children are called left and right child. It&#39;s legal to just make use of one child per node. </li>
<li>A <strong>Binary Search Tree</strong>: is a Binary Tree, with the additional constraint that the children must be in the right order.The child with the smaller value than it&#39;s parent goes left, the child with the greater or equal value goes right.  </li>
<li>A <strong>Binary Heap</strong> is a Binary Tree with two additional constraints. a) The Binary Tree must be complete, which means that the height of the closest and farthest vertex v from root differs only by at most 1. b) Each node must comply with the heap property. For a max-heap, the property expresses the constraint that the parent must always be greater than it&#39;s children. In the case of a min-heap, the parent must be smaller than the children.  </li>
<li>A <strong>Balanced Binary Search Tree</strong> is a Binary Search Tree that cannot degenerate (in other words, it cannot become a list). When inserting or deleting nodes, it shuffles around nodes such that the height of the tree is kept to an upper bound which is better than n. AVL tree, or Black-Red-Tree are implementations of a Balanced Binary Search Tree.</li>
</ul>
<p>##Tree
Like any other graph, a tree can be represented as either an adjacency list, adjacency matrix or objects. When working with Binary Tree structures, objects are usually used to represent the tree.</p>
<table>
<thead>
<tr>
<th>Representation</th>
<th style="text-align:center">Edge Look up</th>
<th style="text-align:center">Out edges Look up</th>
<th style="text-align:center">Edge Insertion</th>
<th style="text-align:center">Edge Deletion</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adjacency matrix</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(V)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td>Adjacency list</td>
<td style="text-align:center">O(E)</td>
<td style="text-align:center">O(E)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(E)</td>
</tr>
<tr>
<td>Objects</td>
<td style="text-align:center">O(E)</td>
<td style="text-align:center">O(E)</td>
<td style="text-align:center">O(V)</td>
<td style="text-align:center">O(E)</td>
</tr>
</tbody>
</table>
<h3>Notes</h3><ul>
<li>A tree is by definition acyclic and has one edge less than it has vertices.</li>
<li>A tree can be represented in different ways, the &quot;best&quot; representation is relative to the task at hand.</li>
<li>A list is a valid tree.</li>
<li>A complete tree can be represented with a simple array.</li>
</ul>
<h2>Binary Tree</h2><p>A Binary Tree which can be unbalanced, is rarely used in practice as it can degenerate and yield <em>O(n)</em> runtime complexities. Note, that even a list can conform with the constraint of a Binary Tree. Still, the binary tree structure (parent with two children), lays the foundation for Binary Heaps or the Binary Search Tree.</p>
<p>The most important programming concept to keep in mind when solving tree problems is <strong>recursion</strong>. Often in interview problems, the recursion of the Binary Tree either builds up to a solution (top-down) or aggregates information at a node (bottom-up). </p>
<p>A Tree node has two members fields for the children, a member field for the value. It could also have a parent link, especially in cases where we try to avoid recursion.</p>
<pre><code>public class TreeNode {
   int val;
   TreeNode left;
   TreeNode right;
   TreeNode(int x) { val = x; }
}
</code></pre><h3>Binary Tree Traversal</h3><p>A Binary Tree can be traversed using Breadth-first or Depth-first search.
Given the above TreeNode type, we can use recursion to traverse the nodes in different orders.
If we wanted to traverse the Binary Tree in pre-order we can do the following:</p>
<pre><code>public void preorder(TreeNode node) {
    if (node == null) return;
    // process node
    preorder(node.left);
    preorder(node.right);
}
</code></pre><h3>Notes</h3><ul>
<li>A binary tree can be traversed in pre-order, post-order, in-order or level-order.</li>
<li>A list can be a degenerate, yet valid binary tree.</li>
<li>Always make the distinction between Binary Tree and Binary Search Tree as they have very different </li>
</ul>
<h3>Interview questions</h3><ol>
<li>Flatten a Binary Tree</li>
<li>Traverse a Binary Tree (pre-order, in-order, post-order) without using recursion. (This problem will make you think about recursion and how to replace it with data structures.)</li>
<li>Find a subtree in a Binary Tree.</li>
<li>Find common ancestor in Binary Tree. (Think about TreeNode properties) </li>
</ol>
<h2>Binary Heaps</h2><p>A Binary Heap extends a Binary Tree by two properties:</p>
<ul>
<li>it is a <strong>complete Binary Tree</strong></li>
<li>Each vertex v satisfies a <strong>order invariant</strong></li>
</ul>
<p>Binary Heaps have the following complexities:</p>
<ul>
<li>Generating a heap with n elements <code>O(n log n)</code>.</li>
<li>Inserting a node takes <code>O(log n)</code>.</li>
<li>Deleting a node is <code>O(log n)</code>.</li>
<li>Accessing the top element is <code>O(1)</code>.</li>
</ul>
<p>Regarding the implementation of a Binary Heap, we need the following routines:</p>
<ul>
<li><strong>heapify</strong> (Node n): reinforces the heap invariant on Node n. After the call, n will be in the correct position.</li>
<li><strong>build</strong> (int[] array): Given an array, it builds a Binary Heap by applying heapify to all elements.</li>
</ul>
<p>Let&#39;s have a look at an implementation of a Binary Heap, in this case with a maximum heap invariant.</p>
<pre><code>public class MaxHeap {
    int[] sequence;
    int heapSize;
    int sequenceSize;

    public MaxHeap(int[] array) {
        this.sequence = array;
        this.heapSize = array.length;
        this.sequenceSize = array.length;
        build();
    }

    public int[] getHeap () {
        return this.sequence;
    }

    // O(n log n)
    private void build() {
        for (int i = this.sequenceSize - 1; i &gt;= 0; i--) {
            heapify(i);
        }
    }

    // enforces heap property if not already in place, O(log n)
    private void heapify (int pos) {
        int left = 2*pos+1;
        int right = 2*pos+2;
        int largest = pos;
        if (left &lt; this.heapSize &amp;&amp; this.sequence[pos] &lt; this.sequence[right]) {
            largest = right;
        }
        if (right &lt; this.heapSize &amp;&amp; this.sequence[largest] &lt; this.sequence[left]) {
            largest = left;
        }
        if (largest != pos) {
            int tmp = this.sequence[pos];
            this.sequence[pos] = this.sequence[largest];
            this.sequence[largest] = tmp;
            heapify(largest);
        }
    }
}
</code></pre><p>Binary Heaps can be represented with an array. The reason for this lies in the symmetry of a complete Binary Tree.
The above code builds a Binary Heap given an array of integers. 
By providing methods like push(), pop(), top(), the Heap implementation could be turned into a Priority Queue. </p>
<h3>Note</h3><ul>
<li><strong>Heap Sort</strong> is a <code>O(n log n)</code> sorting algorithm which is based on a Binary Heap .</li>
<li>A <strong>Priority Queue</strong> is a Binary Heap, with additional routines for practicality.</li>
</ul>
<h2>Binary Search Tree</h2><p>A Binary Search Tree (BST) has Tree nodes just like the Binary Tree. Binary Search Tree can still degenerate and therefore yield bad complexities.
This is why, it is important to add balancing to a BST.
If we have a complete Binary Search Tree on the other hand we can expect to:</p>
<ul>
<li>find element in <code>log(n)</code></li>
<li>Insert an element in <code>log(n)</code></li>
<li>Delete a node in <code>log(n)</code></li>
</ul>
<h3>Note</h3><ul>
<li>When traversing a BST with in-order traversal, we can obtain the sorted order of the tree nodes.</li>
</ul>
<h3>Interview questions</h3><ol>
<li>Given a binary tree, insert edges that point to the vertex on the right hand side on the same level.</li>
<li>Build a binary search tree from an array. Note: make sure it&#39;s a sorted array.</li>
<li>Verify whether binary tree is a binary search tree.</li>
</ol>
<h2>Balanced Binary Search Tree</h2><p>To be continued, covering AVL Tree, Red-Black-Tree.</p></body></html>